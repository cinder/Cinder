<!DOCTYPE html>
<html>
	<head>
		<!-- Update title -->
		<title>Cinder with Emscripten</title>

		<!-- keywords used for searching -->
		<meta name="keywords" content="guide, emscripten, cinder">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- reference to Cinder classes -->
   		<!-- <ci seealso dox="[CLASS NAME GOES HERE]" label="[NAME OF LINK]"></ci> -->

   		<!-- master stylesheet - these links will be replaced when compiled -->
		<link rel="stylesheet" href="../../_assets/css/foundation.css">
		<link rel="stylesheet" href="../../_assets/css/prism.css">
		<link rel="stylesheet" href="../../_assets/css/style.css">
		<link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300,600,700' rel='stylesheet' type='text/css'>

		<!-- Place additional stylsheet links here, which will be copied over when compiled (optional) -->

	</head>

	<body id="guide-contents" class="language-c++">

        <!-- CONTENT STARTS HERE -->
        <!-- TODO - add to docs after testing api -->
        <section id="Cinder-Audio">
            <h1>Cinder Audio on the web</h1>

            <p>For Emscripten, the audio api is simplified a bit in an effort to make use of the native WebAudio api as much as possible due to the complexity in 
                trying to integrate C++ with the WebAudio api in addition to some parts of the WebAudio api that would have been needed being marked for deprecation.
                There are other fringe benefits such as the audio processing happening on a separate thread. 
                <br/>
                An effort was made to keep the general use of the audio api as similar as possible, but overall you probably won't be able to directly port 
                your audio code to the web without some re-writing. 
            </p>
            
            <p>Overall the pattern is similar and perhaps is best explained through a code snippit</p>
            <br/>
            <code>
                auto ctx = AudioContext::Instance();

                oscilator = ctx->makeNode(new NativeNode(WebAudioApiNode::OscillatorNode));
                oscilator->setAudioParam("frequency",255);
            
                gain = ctx->makeNode(new CustomNode());
            
                oscilator >> gain >> ctx;
            
                ctx->enable();
            </code>
            <br/>
            <p>In essance, the audio api is slimmed down to just 2 types of nodes - a <code>NativeNode</code> and a <code>CustomNode</code></p>

            <h2>Native Nodes</h2>
            <p>Native notes represent native WebAudio nodes that are already built into the browser. Beyond simple settings, these nodes are essentially self-contained 
                black boxes that prevent you from directly touching their internal buffer. That is until you connect a ....
            </p>

            <h2>CustomNode</h2>
            <p>This node is, as it's name suggests, a node that you can customize. The core of this class is the <code>process</code> function. It will get passed 
            a set of data arrays </p>
            <ul>
                <li>
                    <b>inputs</b> - This array corresponds to the input data that's coming in from the previous node in the chain. 
                </li> 
                <li>
                    <b>outputs</b> - This array corresponds to any output information you want to send to the next node in the chain or the output destination.  
                </li>
                <li>
                    <b>channelCount</b> - This is just an int corresponding to the number of channels that are being used. 
                </li>
            </ul>

            <p>Note that this information is passed in from a singular <code>emscripten::val</code> object.</p>
        </section>

		<!-- END CONTENT -->

		<!-- Scripts -->
		<script src="../../_assets/js/prism.js" type="text/javascript"></script>
		<!-- Place additional scripts here (optional) -->
		<!-- <script type="text/javascript"></script> -->

	</body>
</html>
