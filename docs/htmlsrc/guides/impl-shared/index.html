<!DOCTYPE html>
<html>
   <head>
      <title></title>
   </head>
   <ci seealso dox="ci::gl::Texture" label="Implicitly Shared Objects"></ci>
   <body>
      <div class="textblock">
         <h2>Introduction</h2>
         <p>A common design feature throughout Cinder is the idea of implicitly shared objects. To look at how this works, let's consider the following bit of code: </p>
         <pre><code class="language-cpp">
gl::Texture textureA, textureB;
textureA = loadImage( "cinder_logo.png" ); // create an OpenGL texture from an image file
textureB = textureA;
         </code></pre>
         <!-- fragment -->
         <p> In this instance, <em>textureB</em> becomes another handle to the same texture as <em>textureA</em>. Consider for a moment the alternative. If the assignment above were to create a clone of the texture, this would be an extremely expensive operation. We'd need to copy all of the pixels off of the GPU, allocate a new Texture, and then upload a copy of all of these pixels back to the GPU. That's rough. However, the way <ci>gl::Texture</ci> and other classes like it are designed, this assignment is instead very fast. Basically assignment says, "here's the OpenGL Texture I'm referring to. You refer to it too."<br />
            <br />
         </p>
         <p>This is especially convenient in a couple of scenarios. First, returning Cinder objects from functions: </p>
         <pre><code class="language-cpp">
gl::Texture createCheckboardTexture()
{
    Surface checkerboardSurface( 256, 256, false );
    ... algorithm to make a checkboard pattern ...
   return gl::Texture( checkerboardSurface );
}

gl::Texture myCheckerboard = createCheckerboardTexture();</code></pre>
         <!-- fragment -->
         <p> In the hypothetical example above, we have a function which returns a new OpenGL texture as its result. This is made efficient and easy because of implict sharing. <em>myCheckerboard</em> is made to refer to the same <ci>gl::Texture</ci> which was allocated and returned by the createCheckerboardTexture() function. The implictly shared object design allows you to write natural code like this without worrying about the performance or safety of returning a class as a result.<br />
            <br />
            A second common use case is creating STL containers like <code>std::vector&lt;&gt;</code> out of Cinder's core types: 
         </p>
         <pre><code class="language-cpp">
std::vector<gl::Texture> myTextures;
myTextures.push_back( createCheckerboardTexture() );
         </code></pre>
         <!-- fragment -->
         <p> This code allocates an STL vector of textures, and then appends to this vector the result of a call to our createCheckerboardTexture() function. Safe, fast &amp; easy. <br />
         </p>
         <h2>Leaks</h2>
         <p>One of the most important advantages of the implicitly shared design is that it makes it nearly impossible to leak memory or other resources. This is because implicitly shared objects are able to sort out amongst themselves when a resource is no longer being used, and will free that resource as soon as nobody is interested in it anymore. Last one to leave turns out the lights. This is very similar to garbage collection, but is even more powerful for the fact that resources are freed immediately, and not at some undetermined future time. Consider this code: </p>
         <pre><code class="language-cpp">
gl::Texture outside;                                  // 1
{                                                     // 2
   gl::Texture temp1 = createCheckerboardTexture();   // 3
   gl::Texture temp2 = createCheckerboardTexture();   // 4
   outside = temp1;                                   // 5
}                                                     // 6     </code></pre>
         <!-- fragment -->
         <p> At line 3, <em>temp1</em> is allocated and assigned a new texture. At line 4, <em>temp2</em> is also allocated and assigned a different texture. At line 5, we assign <em>outside</em> to refer to the same texture as <em>temp1</em>. At line 6, both <em>temp1</em> and <em>temp2</em> go out of scope, and their destructors are called. No other gl::Texture refers to the texture allocated at line 4, so this OpenGL texture is destroyed automatically and immediately. However <em>outside</em> still exists, and still refers to the same texture <em>temp1</em> did, so when <em>temp1</em> is destructed, the texture it referred to is not destroyed. You can trust that Cinder's classes will clean up after themselves, making it very difficult to write the sorts of leaks or double-frees that keep C++ programmers awake at night. <br />
         </p>
         <h2>Nulls</h2>
         <p>One useful feature of this design is that implicitly shared objects can be the equivalent of a null pointer, which is to say they can be empty. The default constructor will allocate an object in this null state: </p>
         <pre><code class="language-cpp">
Surface mySurface; // default-constructed to be null &amp; empty</code></pre>
         <!-- fragment -->
         <p> We can test this in the same ways we might test a pointer or a boolean </p>
         <pre><code class="language-cpp">
if( mySurface )
   ... // do something with my non-null Surface
         </code></pre>
         <!-- fragment -->
         <p> <br />
         </p>
         <h2>Advanced: Implementation</h2>
         <p>You don't need to understand how Cinder classes implement this implicit sharing to make use of it. If you're just getting started with C++, you can stop reading, trusting that Cinder is managing things behind the scenes for you. But for more advanced users it's a helpful thing to understand, especially if you intend to contribute code back to the Cinder community. Let's continue using the <ci>gl::Texture</ci> class as an example. If you open <a class="el" href="_texture_8h.html">gl/Texture.h</a> and look inside, you'll see that it contains a member class called Obj. This class actually contains the "guts" you might have expected to see inside gl::Texture itself - things like the width of the texture in pixels (<em>mWidth</em>), or the OpenGL texture ID (<em>mTextureID</em>). The only member variable gl::Texture itself contains is a std::shared_ptr to one of these Obj's, called <em>mObj</em>. Now take a look at how a function like gl::Texture::getId() is implemented: </p>
         <pre><code class="language-cpp">
GLuint gl::Texture::getId() const
{
   return mObj->mTextureID;
}</code></pre>
         <!-- fragment -->
         <p> As you can see, the gl::Texture returns its Obj's <em>mTextureID</em>. You'll find this sort of pattern used throughout <ci>gl::Texture</ci>'s implementation. Now consider what an assignment does: </p>
         <pre><code class="language-cpp">gl::Texture textureA = textureB;</code></pre>
         <!-- fragment -->
         <p> While we did not have to write it explicitly (because C++ implicitly generated our operator= and copy constructor for us), this is the equivalent of: </p>
         <pre><code class="language-cpp">textureA.mObj = textureB.mObj;</code></pre>
         <!-- fragment -->
         <p> Because of the way that shared_ptr's work, both <em>textureA</em> and <em>textureB</em> point to the same Obj. The fact that this is implemented using a shared_ptr is an implementation detail - the same effect could be achieved with a different technique, but shared_ptr's are a proven, easy way to make this possible, and it's one we'd recommend if you're designing your own classes to behave similarly. <br />
         </p>
         <h2>Advanced: Precedents</h2>
         <p>This implicitly shared object pattern is not something unique to Cinder. If you are interested to see examples of it in other C++ class libraries, you can read about <a href="http://doc.trolltech.com/4.3/shared.html">Qt's implementation here</a>, <a href="http://docs.wxwidgets.org/trunk/overview_refcount.html#overview_refcount_destruct">wxWidgets' here</a> or take a look at the design of OpenCV's <a href="http://opencv.willowgarage.com/documentation/cpp/memory_management.html">memory management</a>. </p>
      </div>
   </body>
</html>