<!DOCTYPE html>
<html><head>
    <meta charset="utf-8"/>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>

    <title>Audio Api Guide</title> <!-- dynamic partial defined in python -->
    

    <link href="../../_assets/css/foundation.css" rel="stylesheet"/>
    <link href="../../_assets/css/prism.css" rel="stylesheet" type="text/css"/>
    <link href="../../_assets/css/treeview.css" rel="stylesheet" type="text/css"/>
    <link href="../../_assets/css/cinder_docs.css" rel="stylesheet" type="text/css"/>
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,600,700" rel="stylesheet" type="text/css"/>
    <link href="http://fonts.googleapis.com/css?family=Libre+Baskerville:400,400italic" rel="stylesheet" type="text/css"/>

</head>
<body class="guide language-cpp">

    <!-- start offcanvas content for responsive sliding nav -->
    <div class="off-canvas-wrap wrapper" data-offcanvas="">
        <main class="inner-wrap">

            <section class="main-section">

                <!-- top section -->
                <div id="top-primary">
                    <!-- main nav -->
                    
                    <nav class="show-for-medium-up content row top-bar" data-topbar="" id="main-nav" role="navigation">
                      <div class="branding columns medium-4 large-3">
                        <div class="navbar-header">
                          <a class="navbar-brand" href="../../index.html"></a><div class="cinder-version">0.9.0</div>
                        </div>
                      </div>

                    <div class="columns medium-8 large-9">
                        <section class="top-bar-section">
                            <!-- Right Nav Section -->
                            <ul class="right">
                              <li class="active">
                                    </li><li id="nav_search">
                                    <div id="search">
                                            <input id="search-input" type="text"/>
                                            <div id="search-results"></div>
                                        </div>
                                        <script src="../../search_index.js" type="text/javascript"></script>
                                  </li>
                              
                            </ul>

                            <!-- Left Nav Section -->
                            
                            <ul class="tablist nav">
                              <li class="" id="nav_reference">
                                <a href="../../reference/geometry.html">Reference</a></li>
                              <li class="active" id="nav_guides">
                                <a href="../index.html">Guides</a></li>
                              <li class="" id="nav_namespaces">
                                <a href="../../namespaces.html">Namespaces</a></li>
                              <li class="" id="nav_classes">
                                <a href="../../classes.html">
                                  Classes</a></li>
                            </ul>
                        </section>
                      </div>
                    </nav>

                    <!-- for any additional content you'd want to put up here -->
                    
                </div>

                <!-- mobile nav -->
                <nav class="tab-bar show-for-small">
                  <section class="left-small">
                    <a class="left-off-canvas-toggle menu-icon" href="#"><span></span></a>
                  </section>

                  <section class="middle tab-bar-section">
                    <h2 class="title">Cinder</h2>
                  </section>

                </nav>

                <aside class="left-off-canvas-menu">
                  <ul class="off-canvas-list">
                    <li><label>Cinder Documentation</label></li>
                    <li id="nav_reference"><a href="../../reference/index.html">Reference</a></li>
                    <li id="nav_guides"><a href="../index.html">Guides</a></li>
                    <li id="nav_namespaces"><a href="../../namespaces.html">Namespaces</a></li>
                    <li id="nav_classes"><a href="../../classes.html">Classes</a></li>
                    <li><a href="http://libcinder.org/download/">Download</a></li>
                  </ul>
                </aside>
                
                
                <div data-equalizer="content" id="main-content">

                    
<div class="row content content-row" id="container">
    <div class="columns large-3">

    </div>

    <div class="columns large-9 content" data-equalizer-watch="content">


    <ci dox="cinder::audio" label="Audio in Cinder" seealso=""></ci>


   <div class="contents">
   <div class="toc">
      <h3>Table of Contents</h3>
      <ul>
         <li class="level1"><a href="#design">Design</a></li>
         <li class="level1"><a href="#voice">Voice - simple audio file or callback player</a></li>
         <li class="level1"><a href="#audio_buffers">Audio Buffers</a></li>
         <li class="level1">
            <a href="#modular">Modular API</a>
            <ul>
               <li class="level2"><a href="#context">Context</a></li>
               <li class="level2"><a href="#node">Node</a></li>
               <li class="level2"><a href="#device_output">OutputDeviceNode</a></li>
               <li class="level2"><a href="#device_input">InputDeviceNode</a></li>
               <li class="level2"><a href="#monitor">MonitorNode and MonitorSpectralNode</a></li>
               <li class="level2"><a href="#read_audio">SourceFile and SamplePlayerNode</a></li>
               <li class="level2"><a href="#write_audio">BufferRecorderNode</a></li>
               <li class="level2"><a href="#ChannelRouterNode">ChannelRouterNode</a></li>
               <li class="level2"><a href="#other_nodes">Other Nodes - GenNode's and Effects</a></li>
            </ul>
         </li>
         <li class="level1"><a href="#param">Param - sample accurate audio parameters</a></li>
         <li class="level1">
            <a href="#nodes_voices">Accessing the Nodes within a Voice</a>
            <ul>
               <li class="level2"><a href="#voice_nodes">How a Voice manages its Nodes</a></li>
               <li class="level2"><a href="#voice_direct">Manually directing the Voice output</a></li>
            </ul>
         </li>
         <li class="level1">
            <a href="#platform_specific">Platform Specific Notes</a>
            <ul>
               <li class="level2"><a href="#ios_specific">iOS</a></li>
            </ul>
         </li>
         <li class="level1">
            <a href="#other">Other</a>
            <ul>
               <li class="level2"><a href="#Tests">Tests</a></li>
            </ul>
         </li>
      </ul>
   </div>
   <div class="textblock">
      <p>This document provides an overview of the audio capabilities in cinder. You can use this, along with the samples in the <em>samples/_audio</em> folder, as an entry point into the <a href="../../namespacecinder_1_1audio.html">ci::audio</a> namespace.</p>
      <h1><a class="anchor" id="design"></a>
         Design
      </h1>
      <p>The <code>ci::audio</code> namespace consists of a few different components and layers of abstraction:</p>
      <div class="image">
         <img alt="audio_layers.png" src="images/audio_layers.png"/>
      </div>
      <p>The design is meant to accomodate a wide range of applications. The <a href="../../classcinder_1_1audio_1_1_voice.html">Voice</a> API is appropriate when you simply need to play an audio track, or want a simple way to write to a continuous audio stream using a callback.</p>
      <p>The core of the design is the modular API, which provides a set of extendable audio tools that can be connected in flexible ways depending on an application's needs. For those who plan to do extensive audio work with cinder, they will be served best by using the Node system. It draws from concepts found in other popular modular audio API's, namely <a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html">Web Audio</a> and <a href="http://puredata.info/">Pure Data</a>, while combining many of cinder's existing design patterns. We also take full advantage of C++11 features such as smart pointers, <code>std::atomic</code>'s, and <code>std::mutex</code>'s.</p>
      <p>A modular API is advantagous because it is proven to be very flexible and allows for reusability without a significant loss in performance. Still, higher level constructs exist and more will be added as time permits. The cinder philosophy remains, "easy things easy and hard things possible."</p>
      <p>For those looking for raw dsp functionality, the <a href="../../namespacecinder_1_1audio_1_1dsp.html">ci::audio::dsp</a> namespace contains a range of high performance tools for most audio processing tasks. They are used by the available <a href="../../classcinder_1_1audio_1_1_node.html">Node</a>s and provide building blocks for custom <a href="../../classcinder_1_1audio_1_1_node.html">Node</a> classes or any other audio processing purposes.</p>
      <h3>Note on code snippets</h3>
      <p>For the sake of trying to keep the code snippets short, it is assumed that the code is in a .cpp file and there is a <code>using namespace ci;</code> within scope, so the <code>ci::</code> qualifier has been dropped.</p>
      <h1><a class="anchor" id="voice"></a>
         Voice - simple audio file or callback player
      </h1>
      <p>For those who need only to play back a sound file or want a simple processing function, you may not need to look further than what is provided in the <a href="../../classcinder_1_1audio_1_1_voice.html">Voice</a> API. <code>Voice</code>s are high level objects that sit above the modular system, managing a small chain of <a href="../../classcinder_1_1audio_1_1_node.html">audio::Node</a>s that perform the necessary processing. They are meant to require little work on the user's part, so you don't need to worry about things like what the playback samplerate is or to what hardware device audio is sent, at the cost of less flexibility.</p>
      <p>The following is an example of how to play a sound file with an <code>audio::Voice</code> (Details about how to load sound files will be explained in the section on <a class="el" href="#read_audio">SourceFile and SamplePlayerNode</a>):</p>
<pre><code class="language-cpp">
// declare somewhere in your class interface:
audio::VoiceRef mVoice;

void MyApp::setup()
{
    audio::SourceFileRef sourceFile = audio::load( app::loadAsset( "soundfile.wav" ) );
    mVoice = audio::Voice::create( sourceFile );

    // Start playing audio from the voice:
    mVoice-&gt;start();
}
</code></pre>
      </div>

      <!-- fragment -->
      <p>Later, you can call <code>mVoice-&gt;stop()</code> when you want to quit playing audio.</p>
      <p>The <a href="../../classcinder_1_1audio_1_1_voice.html#af1e688f5b55270904880179a444fa127">audio::Voice::create()</a> method returns a shared_ptr to a Voice sub-class (ex, in the case of playing an audio file, returns <code>VoiceSamplePlayerRef</code>, but the user will generally only need to maintain this by storing it in a VoiceRef instance variable. It is necessary to store the returned VoiceRef because once it goes out of scope, it will be disconnected from the audio graph and destroyed. This is fairly cheap, however (much cheaper than creating the <code>SourceFile</code> via <a href="../../namespacecinder_1_1audio.html#ac2e5c9ebd3ff830bcebaef49326d9dab">audio::load()</a>, for example), so if you need to later play a different file, you can safely call <code>Voice::create()</code> again and assign it to your <code>mVoice</code> instance variable.</p>
      <p>You can also use a <code>Voice</code> for basic audio processing by providing a <code>std::function</code> callback to the <code>create()</code> method. This can be useful for educational purposes or quick experiments.</p>
<pre><code class="language-cpp">
mPhase = 0.0f; // float stored in class

mVoice = audio::Voice::create( [this] ( audio::Buffer *buffer, size_t sampleRate ) {
   float *channel0 = buffer-&gt;getChannel( 0 );

   // generate a 440 hertz sine wave
   float phaseIncr = ( 440.0f / (float)sampleRate ) * 2 * (float)M_PI;
   for( size_t i = 0; i &lt; buffer-&gt;getNumFrames(); i++ )    {
       mPhase = fmodf( mPhase + phaseIncr, 2 * M_PI );
       channel0[i] = std::sin( mPhase );
   }
} );
</code></pre>

      <!-- fragment -->
      <p>Users should be aware that the callback is processing on the background audio thread, so any data that interacts with the main thread needs to be synchronized.</p>
      <p>Each Voice has controls for volume and 2d panning. Here is an example of how you'd control these with the mouse:</p>
<pre><code class="language-cpp">
void MyApp::mouseDown( app::MouseEvent event )
{
    mVoice-&gt;setVolume( 1.0f - (float)event.getPos().y / (float)getWindowHeight() );
    mVoice-&gt;setPan( (float)event.getPos().x / (float)getWindowWidth() );
}
</code></pre>

      <!-- fragment -->
      <p>Related Samples:</p>
      <ul>
         <li><a href="https://github.com/cinder/Cinder/blob/master/samples/_audio/VoiceBasic/src/VoiceBasicApp.cpp">VoiceBasic</a></li>
         <li><a href="https://github.com/cinder/Cinder/blob/master/samples/_audio/VoiceBasicProcessing/src/VoiceBasicProcessingApp.cpp">VoiceBasicProcessing</a></li>
      </ul>
      <h1><a class="anchor" id="audio_buffers"></a>
         Audio Buffers
      </h1>
      <p>Before jumping into the meat and potatoes, its a good idea to be introduced to <a href="../../classcinder_1_1audio_1_1_buffer_t.html">audio::Buffer</a>, the class used for passing audio samples around in <code>ci::audio</code>. Audio data is most commonly handled in two different manners:</p>
      <ol type="1">
         <li>a contiguous stream of 'blocks' of equal length, which is how real-time processing is achieved.</li>
         <li>as a single unit, such as the uncompressed data of sound file.</li>
      </ol>
      <p>In both cases, there is a number of frames (a frame consists of a sample for each channel) and a number of channels that make up the layout of the <code>Buffer</code>. Usually <code>Buffer</code>s are passed by pointer if they are only meant to be filled (like from a process function) or <code>shared_ptr&lt;Buffer&gt;</code> (<code>BufferRef</code>'s) if it makes sense to hold onto a shared buffer. This isn't required though, and in some cases you indeed want to copy the entire Buffer, such as multi-threaded situations where you are passing a Buffer from the audio thread back to the main thread. For these cases, the copy constructor is enabled.</p>
      <p>It is also important to note that samplerate is not a property of the buffer data - this is to allow for flexibility of how the data is interpreted. Instead, samplerate is determined from the context in which the audio data is being used.</p>
      <h3>Layout</h3>
      <p>The standard <code>Buffer</code> class used when passing audio between different components stores its channels contiguously (non-interleaved). This means that right after channel 0 (ex. left speaker) ends, the next sample in the internal array is the first sample of channel 1 (ex. right speaker). For convenience, the <code>Buffer::getChannel( size_t )</code> method with return a float* offset to the provided channel index, and also does some debug assertions that the index is in bounds. In the rare cases that interleaved audio is required (ex. interfacing with third-party or system level API's), there is a <code>BufferInterleaved</code> variant.</p>
      <p>Currently all processing is handled in single floating point precision. However, the Buffer class is actually a typedef'ed <code>BufferT&lt;float&gt;</code>, so if a different sample format is required, one can use the BufferT class directly and provide the sample type. While this is not directly interchangeable with public interfaces in the <code>ci::audio</code> namespace, there are conversion utilities provided in <a class="el" href="_converter_8h.html">cinder/audio/dsp/Converter.h</a>.</p>
      <p>In all <code>Buffer</code> variants, you can get at the actual data store with the <code>Buffer::getData()</code> method, which returns a pointer to an array and can be used however the user wishes, provided they understand the buffer layout.</p>
      <h3>Resizing</h3>
      <p>The standard <code>Buffer</code> class is not resizable once constructed. However, sometimes it is necessary or more efficient to resize a buffer after construction, which is facilitated by the <code>BufferDynamic*</code> variants. <code>BufferDynamic</code> has the methods, <code>setNumFrames()</code>, <code>setNumChannels()</code>, and <code>setSize()</code> (for both frames and channels at the same time), which will realloc the internal data store if required. If the new size (frames * channels) is smaller or equal to the previous size, no reallocation will occur - by default <code>BufferDynamic</code> will only grow in order to prevent runtime reallocations where possible. If you would like to free up extra space, you can use the provided <code>shrinkToFit()</code> method.</p>
      <h1><a class="anchor" id="modular"></a>
         Modular API
      </h1>
      <p>At the core of the <code>ci::audio</code> architecture is a modular, Node-based system that allows you to interconnect audio building blocks, such as sample players, waveform generators or effects, in a flexible manner appropriate to a specific application. A large influence of cinder's design comes from the <a href="http://webaudio.github.io/web-audio-api/">Web Audio spec</a> and for those interested, it has a fantastic introduction to <a href="http://webaudio.github.io/web-audio-api/#modular-routing">modular routing</a> and the motivations behind it.</p>

      <h2><a class="anchor" id="context"></a>
         Context
      </h2>
      <p>The <a href="../../classcinder_1_1audio_1_1_context.html">audio::Context</a> class manages platform specific audio processing and thread synchronization between the 'audio' (real-time) and 'user' (typically UI/main, but not limited to) threads. There is one 'master', which is the only hardware-facing Context. All <code>Node</code>s are created using the Context, which is necessary for thread synchronization. A new Node is created like the following:</p>
<pre><code class="language-cpp">
auto ctx = audio::Context::master();
mNode = ctx-&gt;makeNode( new NodeType );
</code></pre>

      <!-- fragment -->
      <p>There are a couple important parameters governed by the current Context, which <code>Node</code>s use to configure their internal buffer layout:</p>
      <ul>
         <li><b>samplerate</b>: the number of processing samples per second, typically 44,100 or 48,000.</li>
         <li><b>frames per block</b>: processing is sectioned up into blocks (an array of numbers, usually a power of two) to facilitate real-time operations. The default value is 512, though some systems can go much lower (like mac).</li>
      </ul>
      <p>These parameters are ultimately configured by the Context's <code>OutputNode</code> (accessible with <code>Context::getOutput()</code>), which is currently always of type <code>OutputNodeDevice</code>. This means that the samplerate and frames-per-block settings are governed by your system's hardware settings.</p>
      <p>It is worth noting that these values can change at runtime either by the user or system, which will cause all Nodes within a Context to be reconfigured. This should in general just work, though authors of <code>Node</code>s should be aware of this possibility when deciding how to manage their Buffers.</p>

      <h2><a class="anchor" id="node"></a>
         Node
      </h2>
      <p>A <a href="../../classcinder_1_1audio_1_1_node.html">audio::Node</a> is the fundamental building block for audio processing graphs. They allow for flexible combinations of synthesis, analysis, effects, file reading/writing, etc., and are meant to be easily subclassed. There are a two important Node types also worth mentioning upfront:</p>
      <ul>
         <li><a href="../../classcinder_1_1audio_1_1_output_node.html">OutputNode</a>: an endpoint at the end of an audio graph. Has no outputs.</li>
         <li><a href="../../classcinder_1_1audio_1_1_input_node.html">InputNode</a>: an endpoint at the beginning of an audio graph. Has no inputs.</li>
      </ul>

      <p><code>Node</code>s are connected together to from an audio graph. For audio to reach the speakers, the last Node in the graph is connected to the Context's OutputNode:</p>
<pre><code class="language-cpp">
auto ctx = audio::Context::master();
mSine = ctx-&gt;makeNode( new audio::GenSineNode );
mGain = ctx-&gt;makeNode( new audio::GainNode );

mSine-&gt;connect( mGain );
mGain-&gt;connect( ctx-&gt;getOutput() );
</code></pre>
      <!-- fragment -->

      <p><code>Node</code>s are connected from source to destination. A convenient shorthand syntax that is meant to represent this is as follows:</p>
<pre><code class="language-cpp">mSine &gt;&gt; mGain &gt;&gt; ctx-&gt;getOutput();</code></pre>
      <!-- fragment -->

      <p>To process audio, each <code>Node</code> subclass implements a virtual method <a href="../../classcinder_1_1audio_1_1_node.html#a50a63b69a4c7b52b669a9489a806d5f4">Node::process( Buffer *buffer )</a>. Processing can be enabled or disabled on a per-Node basis. While <code>NodeEffect</code>s are enabled by default, <code>NodeInput</code>s must be turned on before they produce any audio. <code>OutputNode</code>s are managed by their owning <code>Context</code>, so you enable it by enabling the entire <code>Content</code>:</p>
<pre><code class="language-cpp">
mSine-&gt;enable();
ctx-&gt;enable();
</code></pre>
      <!-- fragment -->

      <p>It is important to note that enabling or disabling the Context controls the processing of the entire audio graph - no audio will be processed at all if it is off and 'audio time' will not progress, whether or not an individual <code>Node</code> is enabled. Not only can you use this to save on cpu / power when you need to, it is also a useful catch-all way to shut off the audio processing thread. On the flip side, <ci code="" dox="ci::audio::dx::disable" kind="namespace" title="Disables the OpenGL State state. Equivalent to calling to glDisable( state );. ">disable()ing an individual <code>Node</code> has no effect on any other <code>Node</code> - it effectly becomes a 'pass through' (though channel management, such as upmixing or downmixing, still must occur).</ci></p>

      <p>The reason why the above is true is that, although <code>Node</code>s are (by convention) connected source &gt;&gt; destination, the actual processing follows the 'pull model', i.e. destination (recursively) pulls the source. The bulk of the work is done by <code>Node::pullInputs()</code>, which ultimately ends up calling the virtual <code>Node::process()</code> method with the <code>Buffer</code> that should be filled with processed audio.</p>

      <p>Other Node features include:</p>
      <ul>
         <li>can be enabled / disabled / connected / disconnected while audio is playing</li>
         <li>supports multiple inputs, which are implicitly summed to their specified number of channels.</li>
         <li>supports multiple outputs, which don't necessarily have to be connected to the Context's output( they will be added to the 'auto pull list').</li>
         <li>Feedback is supported by connecting <code>Node</code>s in a cycle, although for this to make sense there must be a Node that overrides <code>supportsCycles()</code> and returns true. The build in <code>Delay</code> is the primary user of this feature.</li>
         <li>If possible (ex. one input, same # channels), a Node will process audio in-place</li>
         <li><a href="../../classcinder_1_1audio_1_1_node.html#ad470f86568ddb436c7d55eb4dddc93c2">Node::ChannelMode</a> allows the channels to be decided based on either a <code>Node</code>s input, it's output, or specified by user.</li>
      </ul>
      <p>Related Samples:</p>
      <ul>
         <li><a href="https://github.com/cinder/Cinder/blob/master/samples/_audio/NodeBasic/src/NodeBasicApp.cpp">NodeBasic</a></li>
         <li><a href="https://github.com/cinder/Cinder/blob/master/samples/_audio/NodeAdvanced/src/NodeAdvancedApp.cpp">NodeAdvanced</a></li>
      </ul>
      <h2><a class="anchor" id="device_output"></a>
         OutputDeviceNode
      </h2>
      <p>The endpoint in an audio graph is currently always <a href="../../classcinder_1_1audio_1_1_output_device_node.html">OutputDeviceNode</a>, the Node that represents and sends audio to the hardware device on your computer. The default <code>Context</code> initializes this to a sane default when it is first accessed, with stereo channels (or mono if that is all that is available).</p>
      <p>In order to support non device Context's in the future, <code>Context::getOutput()</code> returns an <code>OutputNode</code>, the parent class of <code>OutputDeviceNode</code>. However, you can safely typecast it, which will allow you to get at the <code>audio::DeviceRef</code> and more information related to your hardware device:</p>
<pre><code class="language-cpp">
#include "cinder/audio/OutputNode.h"

auto ctx = ci::audio::master();
audio::DeviceRef dev = dynamic_pointer_cast&lt;audio::OutputDeviceNode&gt;( ctx-&gt;getOutput() )-&gt;getDevice();

ci::app::console() &lt;&lt; "device name: " &lt;&lt; dev-&gt;getName() &lt;&lt; endl;
ci::app::console() &lt;&lt; "num output channels: " &lt;&lt; dev-&gt;getNumOutputChannels() &lt;&lt; endl;
</code></pre>
      <!-- fragment -->

      <p>There is also an easier way to get the default device, with the static <code>audio::Device::getDefaultOutput()</code> method.</p>
      <h3>Specifying a non-default Device</h3>
      <p>If you need the Context to address a device other than the system default, you must create a LineOut with the appropriate <code>ci::audio::DeviceRef</code>, using the platform-specific virtual <code>Context::createOutputDeviceNode()</code> method. You then assign that as the master <code>Context</code>'s <code>OutputNode</code>:</p>
<pre><code class="language-cpp">
auto ctx = ci::audio::master();
auto device = ci::audio::Device::findDeviceByName( "Internal Speakers" );
ci::audio::OutputDeviceNodeRef output = ctx-&gt;createOutputDeviceNode( device );
ctx-&gt;setOutput( output );
</code></pre>
      <!-- fragment -->

      <p>The device name can be found in your system settings or by iterating the <code>DeviceRef</code>'s returned by <code>Device::getDevices()</code> and looking at its <code>getName()</code> property. As an alternative to specifying the device by name, you can use <code>findDeviceByKey()</code>, which is a platform-agnostic, unique identifier that is internally generated.</p>
      <h3>Specifying a Channel Count Other than Stereo (the default)</h3>
      <p>If you intend to handle a channel count other than the default stereo pair, you need to create a LineOut and pass in the desired channel count in its optional <code>Node::Format</code> argument.</p>
<pre><code class="language-cpp">
auto format = ci::audio::Node::Format().channels( 10 );
ci::audio::OutputDeviceNodeRef output = ctx-&gt;createOutputDeviceNode( device, format );
ctx-&gt;setOutput( output );
</code></pre>

      <!-- fragment -->
      <p><b>note</b>: Replacing the master <code>Context</code>'s output will cause a context-wide <code>Node::uninitialize()</code> and <code>Node::initialize()</code>. This is because the Context controls variables that the <code>Node</code>s rely on, such as samplerate and frames-per-block. While in some cases it may be unnoticeable, it's usually a good idea to call <ci code="" dox="ci::audio::dx::Context::disable()" title="Disables the OpenGL State state. Equivalent to calling to glDisable( state );. ">Context::disable()</ci> (or do a more robust halt of your graph) beforehand to prevent unexpected audio clicks.</p>
      <h2><a class="anchor" id="device_input"></a>
         InputDeviceNode
      </h2>
      <p><a href="../../classcinder_1_1audio_1_1_input_device_node.html">InputDeviceNode</a> is used to get microphone or other incoming hardware audio into the audio graph. Its interface is very similar to <code>OutputDeviceNode</code>, most importantly being the <code>getDevice()</code> method, which returns the owned <code>audio::DeviceRef</code>. As with <code>OutputDeviceNode</code>, you must create the InputDeviceNode using the platform-specific virtual method <code>Context::createInputDeviceNode()</code>:</p>
<pre><code class="language-cpp">
ci::audio::InputDeviceNodeRef input = ctx-&gt;createInputDeviceNode();

input &gt;&gt; ctx-&gt;getOutput();
input-&gt;enable();
</code></pre>
      <!-- fragment -->

      <p>The above creates an <code>InputDeviceNode</code> with the default <code>Device</code> and default <code>audio::Node::Format</code>, giving you either stereo channel input or mono if that isn't available, and then connects it directly to the Context's output. As is the case for all <code>InputNode</code>s (<code>InputDeviceNode</code>'s parent class'), you must then call its <ci code="" dox="ci::dx::enable" title="Enables the OpenGL State state. Equivalent to calling to glEnable( state );. ">enable()</ci> method before it will process audio.</p>
      <p>If you want to force mono input, you can specify that with the optional format argument:</p>
<pre><code class="language-cpp">
auto format = ci::audio::Node::Format().channels( 1 );
ci::audio::InputDeviceNodeRef input = ctx-&gt;createInputDeviceNode( Device::getDefaultInput(), format );
</code></pre>
      <!-- fragment -->

      <p>Of course, you can also use a non-default <code>Device</code>, as explained in the section on OutputDeviceNode.</p>
      <p>While the above connection simply routes your microphone input the output speakers, you are able to connect any combination of effects inbetween. You can also connect the input to a <code>MonitorNode</code>, which allows you to get the audio samples back on the main thread for visualization and also doesn't require connection to the speaker output. This is explained in more detail below.</p>
      <h2><a class="anchor" id="monitor"></a>
         MonitorNode and MonitorSpectralNode
      </h2>
      <p>There are a couple <code>Node</code>s that are specifically designed for using audio data for visual or other analytical purposes on the main (UI) thread. Because of the multi-threaded nature of real-time audio processing, care must be taken to do this safely and in a manner that doesn't prohibit the audio thread from doing its necessary processing to deliver a continuous audio stream. This is where <a href="../../classcinder_1_1audio_1_1_monitor_node.html">MonitorNode</a> comes in, which can be inserted anywhere within an audio graph and allows you to grab a buffer of audio samples from the main thread.</p>
      <p>To create and connect the <code>MonitorNode</code>:</p>
<pre><code class="language-cpp">
mMonitor = ctx-&gt;makeNode( new audio::MonitorNode );
mSomeGen &gt;&gt; mMonitor;
</code></pre>
      <!-- fragment -->

      <p>And later to get its <a href="../../classcinder_1_1audio_1_1_buffer_t.html">audio::Buffer</a> for drawing:</p>
<pre><code class="language-cpp">
const audio::Buffer &amp;buffer = mMonitor-&gt;getBuffer();
for( size_t ch = 0; ch &lt; buffer.getNumChannels(); ch++ ) {
    for( size_t i = 0; i &lt; buffer.getNumFrames(); i++ ) {
        draw sample..
    }
}
</code></pre>
      <!-- fragment -->

      <p>Note that in the above example, <code>mMonitor</code> was not connected to the <code>Context::getOutput()</code> - it doesn't have to because it is a special subclass of <code>Node</code>s called <a href="../../classcinder_1_1audio_1_1_node_auto_pullable.html">NodeAutoPullable</a>. Those who subclass this gain the ability to be 'pulled' directly by the owning <code>Context</code>, making it possible to enable processing on the <code>Node</code> without hearing the results. This is often all that is needed, such as in audio visualizer applications, but you are still able to connect <code>NodeAutoPullable</code>s to other outputs if this makes sense in your application. A typical use case for this would be audiovisual applications, where the audio samples at some point in the graph trigger fuel the elements, but you still want audio sent to the speakers.</p>
      <p>One refers to the slice of samples copied from the audio thread the <em>window</em>. The <em>window size</em> is the number of frames the buffer will have that is returned from <code>getBuffer()</code>, which is always a power of two and defaults the number of frames per block in the current <code>Context</code>. If you would like this to be larger, you can specify the size with the <a href="../../structcinder_1_1audio_1_1_monitor_node_1_1_format.html">MonitorNode::Format</a> during construction:</p>
<pre><code class="language-cpp">
auto format = audio::MonitorSpectralNode::Format().windowSize( 4096 );
mMonitor = ctx-&gt;makeNode( new audio::MonitorNode( format ) );
</code></pre>
      <!-- fragment -->

      <h3>RMS Volume</h3>
      <p>If all you need is to get the current volume of the audio stream, you can use the <code>MonitorNode::getVolume()</code> method, which returns the RMS ('root mean squared') value of the the entire window on a scale of 0 to 1. This is generally a good indication of how loud the signal is.</p>
      <h3>Magnitude Spectrum</h3>
      <p>Whereas <code>MonitorNode</code> will give you time-domain samples on the main thread, <code>MonitorSpectralNode</code> is a subclass that will give you frequency-domain samples by way of the <em>Discrete Fourier transform</em> (popularly thought of as the <em>FFT</em>, which for all practical purposes can be thought of as one in the same). This is managed internally using the <a href="../../classcinder_1_1audio_1_1dsp_1_1_fft.html">audio::dsp::Fft</a> class, though for the typical case of viewing the magnitude spectrum of an audio signal, <code>MonitorSpectralNode</code> is all you need.</p>
      <p>The <code>InputAnalyzer</code> makes use of this class, along with an <code>InputDeviceNode</code> as input, to provide a class spectrogram that looks like the following:</p>
      <div class="image">
         <img alt="audio_sample_analyzer.png" src="images/audio_sample_analyzer.png"/>
         <div class="caption">
            Screenshot of InputAnalyzer sample
         </div>
      </div>
      <p> To create and connect up the Nodes for this:</p>
<pre><code class="language-cpp">
void MyApp::setup()
{
    mInputDeviceNode = ctx-&gt;createInputDeviceNode();
    mMonitorSpectralNode = ctx-&gt;makeNode( new audio::MonitorSpectralNode() );

    mInputDeviceNode &gt;&gt; mMonitorSpectralNode;    
}
</code></pre>
      <!-- fragment -->

      <p>And later when you want to draw the magnitude spectrum, you get the magnitude spectrum data with:</p>
<pre><code class="language-cpp">
void MyApp::draw()
{
    const vector&lt;float&gt; &amp;amp;magSpectrum = mMonitorSpectralNode-&amp;gt;getMagSpectrum();

    // draw the vector here...    
}
&lt;/float&gt;</code></pre>
      <!-- fragment -->

      <p>The <code>MonitorSpectralNode::getMagSpectrum()</code> method first makes a copy of the audio samples, then it computes a forward FFT transform and finally converts to polar coordinates. What you get returned to you is the magnitudes only, the phase part is commonly ignored for visualizing the spectrum. While a full explanation of the DFT is out of scope here (<a href="https://ccrma.stanford.edu/~jos/st/">Julius O. Smith's book</a> is a great reference), you interpret the result as an array of <em>bins</em>, where each bin is a frequency range of the decomposed (analyzed) signal and the maximum frequency is the so-called <em>nyquist</em> (half the samplerate).</p>
      <p>Note that whereas in the time domain you receive an <code>audio::Buffer</code>, <code>getMagSpectrum()</code> returns a vector of floats regardless of the number of channels it is processing. If the <code>MonitorSpectralNode</code> has two or more channels, the samples in each channel will first be averaged before the magnitude spectrum is computed. Computing the exact frequency range is simple and well defined:</p>
<pre><code class="language-cpp">
float binFrequency = binIndex * (float)ctx-&gt;getSampleRate() / (float)mMonitorSpectralNode-&gt;getFftSize();
</code></pre>
      <!-- fragment -->
      <p>You can also the method <a href="../../classcinder_1_1audio_1_1_monitor_spectral_node.html#a2c2137917afb0e8f2bf292042f99fafd">MonitorSpectralNode::getFreqForBin( size_t bin )</a> as a convenience.</p>
      <h3>Draw Utilities</h3>
      <p>Throughout the samples, you'll find that most of the audio drawing is done with utility methods defined in <em>samples/_audio/common/AudioDrawUtils.h</em>, including 2D waveform and spectrum plotters. This is partly so that the samples are short and easier to follow, but also to provide users with a decent starting point to begin drawing audio data in their own applications. To make use of them, you are encouraged to copy these functions to your own project's source directory and modify how you see fit.</p>
      <p>Related Samples:</p>
      <ul>
         <li><a href="https://github.com/cinder/Cinder/blob/master/samples/_audio/NodeAdvanced/src/NodeAdvancedApp.cpp">NodeAdvanced</a></li>
         <li><a href="https://github.com/cinder/Cinder/blob/master/samples/_audio/InputAnalyzer/src/InputAnalyzerApp.cpp">InputAnalyzer</a></li>
      </ul>
      <h2><a class="anchor" id="read_audio"></a>
         SourceFile and SamplePlayerNode
      </h2>
      <p>This section explains how to read audio files and play them back within an audio graph, either as a buffer in memory or directly from file.</p>
      <p>Audio files are represented by the <a href="../../classcinder_1_1audio_1_1_source_file.html">audio::SourceFile</a> class, which acts as a handle on the audio file that you can use to decode samples from a wide range of formats. Loading a SourceFile from your assets directory is straightforward:</p>
<pre><code class="language-cpp">audio::SourceFileRef sourceFile = audio::load( loadAsset( "audiofile.wav" ) );</code></pre>
      <!-- fragment -->

      <p>If the file could not be opened for decoding, an <code>AudioFileExc</code> is thrown along with an error description describing the reason of failure.</p>
      <p>To play the SourceFile within an audio graph, you use one of two flavors of <a href="../../classcinder_1_1audio_1_1_sample_player_node.html">SamplePlayerNode</a>, which is the base interface for Node-based sample playback, including common procedures like starting, stopping, seeking, and looping an audio file. There are two concrete flavors of <code>SamplePlayerNode</code>, the first of which being <a href="../../classcinder_1_1audio_1_1_buffer_player_node.html">BufferPlayerNode</a>. This class plays the entire sound file from an in-memory <code>audio::Buffer</code> and can be setup like the following:</p>
<pre><code class="language-cpp">
auto ctx = audio::Context::master();
mBufferPlayer = ctx-&gt;makeNode( new audio::BufferPlayerNode() );
mBufferPlayer-&gt;loadBuffer( sourceFile );
</code></pre>
      <!-- fragment -->

      <p>In contrast, the streaming variant <a href="../../classcinder_1_1audio_1_1_file_player_node.html">FilePlayerNode</a>s only keeps a relatively small buffer in memory, constantly loading samples from disk during playback.</p>
<pre><code class="language-cpp">mFilePlayer = ctx-&gt;makeNode( new audio::FilePlayerNode( sourceFile ) );</code></pre>

      <!-- fragment -->
      <p>Which one you use depends on your application. Usually you want to keep small audio source's, such as sound effects, in memory so that they can quickly be accessed without file i/o. The latency is also much less when playing back directly from memory. Longer audio files, such as a soundtrack, are good candidates for reading from disk at playback time, where the latency doesn't matter as much.</p>
      <p>Both support reading of file types async; <code>BufferPlayer::loadBuffer</code> can be done on a background thread, and FilePlayer can be instructed to read from a background thread with an optional boolean argument.</p>
      <p>For practical reasons <code>audio::SourceFile</code> has built-in support for samplerate conversion, so that the samplerate of the audio you get when processing matches that of the current <code>audio::Context</code>. You can find out what the native samplerate of the file is with <a href="../../classcinder_1_1audio_1_1_source.html#a3563aa3f79c0063f1bc692eda2f4ee01">audio::Source::getSampleRateNative()</a>. You will achieve optimal performance and results if there is no conversion at all, but the decision to support samplerate conversion 'under the hood' was made in order to best achieve the notion of file playback that 'just works'.</p>
      <h3>Supported codec types</h3>
      <ul>
         <li>For mac, see file types <a href="https://developer.apple.com/library/ios/documentation/MusicAudio/Conceptual/CoreAudioOverview/SupportedAudioFormatsMacOSX/SupportedAudioFormatsMacOSX.html">listed here</a>.</li>
         <li>For windows, see file types <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd757927(v=vs.85).aspx">listed here</a>.</li>
         <li>ogg vorbis is supported on all platforms.</li>
      </ul>
      <p>Sample types supported are 16-bit int, 24-bit int, and 32-bit float, all of which will be converted to floating point for processing in an audio graph.</p>
      <p>See also:</p>
      <p><a href="https://github.com/cinder/Cinder/blob/master/samples/_audio/BufferPlayer/src/BufferPlayerApp.cpp">BufferPlayer</a></p>
      <div class="image">
         <img alt="audio_sample_bufferplayback.png" src="images/audio_sample_bufferplayback.png"/>
         <div class="caption">
            Screenshot of BufferPlayer sample
         </div>
      </div>
      <h2><a class="anchor" id="write_audio"></a>
         BufferRecorderNode
      </h2>
      <p>There is currently basic support for recording audio with the <a href="../../classcinder_1_1audio_1_1_buffer_recorder_node.html">BufferRecorderNode</a>. This allows you to write the audio stream from any point in the audio graph into an <code>audio::Buffer</code>, which can then be retrieved to write to disk to use in other creative ways. The following creates and connects a <code>BufferRecorderNode</code> to record from an <code>InputDeviceNode</code>, along with an <a href="../../classcinder_1_1audio_1_1_gain_node.html">GainNode</a> to control the volume of the input:</p>
<pre><code class="language-cpp">
mInput = ctx-&gt;createInputDeviceNode();
mGain = ctx-&gt;makeNode( new ci::audio::GainNode( 0.7f ) );
mRecorder = ctx-&gt;makeNode( new ci::audio::BufferRecorderNode );

mInputDeviceNode &gt;&gt; mGain &gt;&gt; mMonitorSpectralNode &gt;&gt; mRecorder;
</code></pre>
      <!-- fragment -->

      <p>First thing to note is that again, <code>mRecorder</code> is not connected to <code>Context::getOutput()</code>, which isn't necessary because <code>BufferRecorderNode</code> inherits from <a href="../../classcinder_1_1audio_1_1_node_auto_pullable.html">NodeAutoPullable</a>. You can of course connect <code>mRecorder</code>, or any other <code>Node</code> in your graph, up to the output, the choice is up to your application. The following would also work, and the audio is also sent to the speakers:</p>
<pre><code class="language-cpp">
mInputDeviceNode &gt;&gt; mGain &gt;&gt; mMonitorSpectralNode;
mGain &gt;&gt; mRecorder;
mGain &gt;&gt; ctx-&gt;getOutput();
</code></pre>
      <!-- fragment -->

      <p>For optimal performance, you should set the length of the recording buffer before recording (the default is 1 second at a samplerate of 44.1k hertz). This can be done with the constructor or at runtime with <a href="../../classcinder_1_1audio_1_1_buffer_recorder_node.html#a61038dbf03ea6fc928bcb04d616966b8">BufferRecorderNode::setNumFrames()</a>, though be warned that doing this while audio is being recorded has a good chance to cause audio drops because of a likely realloc and array shuffle.</p>
      <p>You start recording samples with the <a href="../../classcinder_1_1audio_1_1_buffer_recorder_node.html#a8bf27a51328d2c296b9ac4f24f60b482">BufferRecorderNode::start()</a> method. Once you have recorded enough samples, you can write the results to an audio file with the following:</p>
<pre><code class="language-cpp">mRecorder-&gt;writeToFile( "recorded.wav" );</code></pre>
      <!-- fragment -->

      <p>Currently the only codec supported for encoding is the popular .wav format. Sample types supported are 16-bit int, 24-bit int, and 32-bit float, which is specified by providing a <a href="../../namespacecinder_1_1audio.html#a17dbbe02a5b638c6362ce63bb3b7789a">audio::SampleType</a> as the second argument to <a href="../../namespacecinder_1_1audio.html#a17dbbe02a5b638c6362ce63bb3b7789a">BufferRecorderNode::writeToFile()</a>.</p>
      <h2><a class="anchor" id="ChannelRouterNode"></a>
         ChannelRouterNode
      </h2>
      <p>ChannelRouterNode is used to map the channels between two connected Nodes. This can be useful in multichannel situations, or to split a stereo Node into two mono Nodes. See above for information on how to setup a multichannel OutputDeviceNode.</p>
      <p>The following routes a <code>SamplePlayer</code> to channel 5 of the Context's output (it has already been configured to as a multi-channel output):</p>
<pre><code class="language-cpp">
auto format = ci::audio::Node::Format().channels( 10 );
auto channelRouter = ctx-&gt;makeNode( new audio::ChannelRouterNode( format ) );
mSamplePlayer &gt;&gt; mChannelRouter-&gt;route( 0, 5 );
</code></pre>
      <!-- fragment -->

      <p>The first argument to <code>ChannelRouterNode::route()</code> is the input channel index, the second is the output channel index.</p>
      <p>If <code>mSamplePlayer</code> happens to be stereo, both channels will be mapped, provided that there are enough channels (starting at the ChannelRouterNode's channel index 5 ) to accomodate. If instead you need to specifically only route a single channel, the route() method can take a third argument to specify the channel count:</p>
<pre><code class="language-cpp">mSamplePlayer &gt;&gt; mChannelRouter-&gt;route( 0, 5, 1 );</code></pre>
      <!-- fragment -->

      <p>Related Samples:</p>
      <ul>
         <li><a href="https://github.com/cinder/Cinder/blob/master/samples/_audio/MultichannelOutput/src/MultichannelOutputApp.cpp">MultichannelOutput</a></li>
      </ul>
      <h2><a class="anchor" id="other_nodes"></a>
         Other Nodes - GenNode's and Effects
      </h2>
      <p>There are quite a few other <code>Node</code> subclasses that have not yet been mentioned, and it is likely that more will appear with time. For a glimpse at what's in the core, you can look at the class hierarchy in <a href="../../classcinder_1_1audio_1_1_node.html">audio::Node</a>'s reference documentation. Many fall into two main categories, generators and effects.</p>
      <p>Those in the first group inherit from the base class <a href="../../classcinder_1_1audio_1_1_gen_node.html">GenNode</a>s. These all share a common goal of generating a waveform and do not support inputs (<code>GenNode</code> itself inherits from <a href="../../classcinder_1_1audio_1_1_input_node.html">InputNode</a>, which disallows inputs). For example, <a href="../../classcinder_1_1audio_1_1_gen_sine_node.html">GenSineNode</a> gives you a perfect sinewave, whereas <a href="../../classcinder_1_1audio_1_1_gen_noise_node.html">GenNoiseNode</a> creates a completely random signal. Perhaps the most useful one in this group is <a href="../../classcinder_1_1audio_1_1_gen_osc_node.html">GenOscNode</a>, which uses bandlimited wavetable lookup to generate the class waveforms such as square, sawtooth or triangle.</p>
      <p>The remaining <code>Node</code>s are mostly types of <em>effects</em>, which process incoming audio in some way or another and pass it on to its output(s). The most common as basic one of these has to be <a href="../../classcinder_1_1audio_1_1_gain_node.html">GainNode</a>, which simply multiplies the incoming signal, adjusting its amplitude. There are also more involved effects, such as <a href="../../classcinder_1_1audio_1_1_delay_node.html">DelayNode</a>, which can be used to create a number of sounds like echo or flanging, or the various filtering node's related to <a href="../../classcinder_1_1audio_1_1_filter_biquad_node.html">FilterBiquadNode</a>. Most of these are used throughout the samples, so check there first to understand how best to use them in your own projects.</p>
      <p>Related Samples:</p>
      <ul>
         <li><a href="https://github.com/cinder/Cinder/blob/master/samples/_audio/NodeAdvanced/src/NodeAdvancedApp.cpp">NodeAdvanced</a></li>
         <li><a href="https://github.com/cinder/Cinder/blob/master/samples/_audio/DelayFeedback/src/DelayFeedbackApp.cpp">DelayFeedback</a></li>
      </ul>
      <h1><a class="anchor" id="param"></a>
         Param - sample accurate audio parameters
      </h1>
      <p>Many of the <code>Node</code>s contain parameters that are controllable over time, or in other words they are animatable. In some situations this is necessary to avoid pops in the audio signal, while it always allows for much creative freedom. This is achieved with the <a href="../../classcinder_1_1audio_1_1_param.html">audio::Param</a> class, allowing you to apply or append 'Event's (the audio equivilant to a <code>ci::Tween</code>) that are then interpreted at a sample-accurate rate.</p>
      <p>For example, the following connects up a simple audio graph containing a <code>GenSineNode</code> and <code>GainNode</code>, and then ramps the parameters on each:</p>
<pre><code class="language-cpp">
auto ctx = audio::master();
auto sine = ctx-&gt;makeNode( new audio::GenSineNode( 220 ) );
auto gain = ctx-&gt;makeNode( new audio::GainNode( 0 ) );

sine &gt;&gt; gain &gt;&gt; ctx-&gt;getOutput();

sine-&gt;getParamFreq()-&gt;applyRamp( 440, 0.5f );
gain-&gt;getParam()-&gt;applyRamp( 0.9f, 0.5f );
</code></pre>
      <!-- fragment -->

      <p>The above applies linear ramps on the <code>Param</code>s, though in some cases this will sound unnatural. Instead, you can use a curve function similar to the <code>ci::Timeline</code> API. The following uses <code>audio::rampOutQuad</code> to provide a more natural decay for the <code>GainNode</code>:</p>
<pre><code class="language-cpp">
auto options = audio::Param::Options().rampFn( &amp;audio::rampOutQuad );
mGain-&gt;getParam()-&gt;applyRamp( 0, 1.5f, options );
</code></pre>
      <!-- fragment -->

      <h1><a class="anchor" id="nodes_voices"></a>
         Accessing the Nodes within a Voice
      </h1>
      <p>Now that we've covered how <code>Voice</code>s work as a high level audio object controller and <code>Node</code>s work within a modular system, here is some information on how <code>Voice</code>s use a composition of <code>Node</code>s to do their work and the interface available for custom routing of a <code>Voice</code>'s output.</p>
      <h2><a class="anchor" id="voice_nodes"></a>
         How a Voice manages its Nodes
      </h2>
      <p>The Voice API sits above and ties into the modular API, which is explained later in this document. Each Voice has a virtual <code>Voice::getInputNode()</code> member function that returns the <code>Node</code> object that is responsible for generating samples (held in a shared_ptr, <code>NodeRef</code>). This is actually a subclass of <code>Node</code> that varies depending on what the concrete type of voice is. For instance, <code>VoiceSamplePlayer</code> will return a <code>SamplePlayerNode</code>. To avoid typecasting, the method <a href="../../classcinder_1_1audio_1_1_voice_sample_player_node.html#a6efd83872a49776a1fd9ba5619ffd339">VoiceSamplePlayerNode::getSamplePlayerNode()</a> is provide. You could use this for more detailed functionality related to sample playback, the following example simply prints the length of the file being played:</p>
<pre><code class="language-cpp">
auto sourceFile = audio::load( loadResource( "soundfile.wav" ) );
auto voice = cinder::audio::Voice::create( sourceFile );
app::console() &lt;&lt; "length of Voice's file: " &lt;&lt; voice-&gt;getSamplePlayerNode()-&gt;getNumSeconds() &lt;&lt; endl;
</code></pre>
      <!-- fragment -->

      <p>Because the Voice internally manages a chain of <code>Node</code>s, the actual <code>Node</code> that is connected to the master output can be retrieved with the virtual <a href="../../classcinder_1_1audio_1_1_voice.html#aa0e7959ea8d7ba1946c7a95b3246ba53">Voice::getOutputNode()</a> member function. This is currently always the <a href="../../classcinder_1_1audio_1_1_pan2d_node.html">Pan2dNode</a>, however a generic <code>NodeRef</code> is returned because the actual type should be opaque to the user.</p>
      <h2><a class="anchor" id="voice_direct"></a>
         Manually directing the Voice output
      </h2>
      <p>By default, a <code>Voice</code> is automatically connected up to <a href="../../classcinder_1_1audio_1_1_context.html#a2cf4a0a6d93249de0ea021556d1c9813">Context::master()</a>, which represents the active output hardware device (ex. speakers). If you plan to direct the <code>Voice</code>'s output to something else, you need to specify this at creation time by passing <code>false</code> to <a href="../../structcinder_1_1audio_1_1_voice_1_1_options.html#a888efd2bcca5965f1058006e2e4c62e5">Voice::Options::connectToMaster()</a>. For example, the following manually connects the <code>Voice</code> up to a <a href="../../classcinder_1_1audio_1_1_monitor_node.html">MonitorNode</a> (visualize the audio signal elsewhere) and then to <a href="../../classcinder_1_1audio_1_1_context.html#a2cf4a0a6d93249de0ea021556d1c9813">Context::master()</a>:</p>
<pre><code class="language-cpp">
auto options = audio::Voice::Options().connectToMaster( false );
mVoice = audio::Voice::create( sourceFile, options );
mMonitor = audio::master()-&gt;makeNode( new audio::MonitorNode );

mVoice-&gt;getOutputNode() &gt;&gt; mMonitor &gt;&gt; audio::master()-&gt;getOutput();
</code></pre>
      <!-- fragment -->

      <h1><a class="anchor" id="platform_specific"></a>
         Platform Specific Notes
      </h1>
      <h2><a class="anchor" id="ios_specific"></a>
         iOS
      </h2>
      <p>The iOS simulator has many problems related to hardware, rendering it quite useless for developing or testing projects with audio. Instead, build for mac desktop when dev'ing and iOS for testing, the two platforms are nearly identical with respect to audio.</p>
      <h1><a class="anchor" id="other"></a>
         Other
      </h1>
      <h2><a class="anchor" id="Tests"></a>
         Tests
      </h2>
      <p>While the samples demonstrate many of the techniques and tools available in a straightfoward manner, there are more exhaustive test applications for each of the various components. They are currently organized into platform-specifc workspaces:</p>
      <ul>
         <li>mac: test/_audio/Audio2Test.xcworkspace</li>
         <li>windows: test/_audio/Audio2Test.msw/Audio2Test.sln</li>
      </ul>
      <p>These are meant to be more for feature and regression testing than anything else, but they may also be a useful way to see the entire breadth of the available functionality. </p>
   </div>




  
  </div>

</div> <!-- dynamic partial defined in python -->
                </div> 
            </section>
            
            <a class="exit-off-canvas"></a>
        </main>

        <footer>
          <div class="row">&copy;Copyright 2015 <a href="http://www.libcinder.org">Cinder</a></div>
        </footer>

    </div>
    
    

    
    <script src="../../_assets/js/jquery.js" type="text/javascript"></script>
    <script src="../../_assets/js/foundation.min.js" type="text/javascript"></script>
    <script src="../../_assets/js/prism.js" type="text/javascript"></script>
    <script src="../../_assets/js/lunr.min.js" type="text/javascript"></script>
    <script src="../../_assets/js/lunr.min.js" type="text/javascript"></script>
    <script src="../../search_index.js" type="text/javascript"></script>
    <script src="../../_assets/js/cinder.js" type="text/javascript"></script>

    <script type="text/javascript">
        // Calling foundation runs through any calls
        // related to foundation 5.
        // One such thing is making sure the column sizes stay in sync
        // $(document).foundation();
        $(document).foundation('offcanvas', 'reflow');
    </script>


</body></html>